import test from "jest-t-assert";
import xxhash from "../src";

// The test cases were taken from tests of other implementation and the
// resulting hashes have been generated by running another implementation.
// All cases used the seed 0.
const testCases = [
  {
    input: "",
    h32: "02cc5d05",
    h64: "ef46db3751d8e999",
    h32Signed: 46947589,
    h64Signed: -1205034819632174695n,
  },
  {
    input: "a",
    h32: "550d7456",
    h64: "d24ec4f1a98c6e5b",
    h32Signed: 1426945110,
    h64Signed: -3292477735350538661n,
  },
  {
    input: "as",
    h32: "9d5a0464",
    h64: "1c330fb2d66be179",
    h32Signed: -1655045020,
    h64Signed: 2031985117650215289n,
  },
  {
    input: "asd",
    h32: "3d83552b",
    h64: "631c37ce72a97393",
    h32Signed: 1032017195,
    h64Signed: 7141644468929262483n,
  },
  {
    input: "asdf",
    h32: "5e702c32",
    h64: "415872f599cea71e",
    h32Signed: 1584409650,
    h64Signed: 4708639809588864798n,
  },
  {
    input: "abc",
    h32: "32d153ff",
    h64: "44bc2cf5ad770999",
    h32Signed: 852579327,
    h64Signed: 4952883123889572249n,
  },
  {
    input: "abcd",
    h32: "a3643705",
    h64: "de0327b0d25d92cc",
    h32Signed: -1553713403,
    h64Signed: -2449070131962342708n,
  },
  {
    input: "0.7278296545100061",
    h32: "432c173f",
    h64: "596877150e8ee48c",
    h32Signed: 1126963007,
    h64Signed: 6442530199275758732n,
  },
  {
    input: "Call me Ishmael. Some years ago--never mind how long precisely-",
    h32: "6f320359",
    h64: "02a2e85470d6fd96",
    h32Signed: 1865548633,
    h64Signed: 189969583671016854n,
  },
  {
    input:
      "The quick brown fox jumps over the lazy dog http://i.imgur.com/VHQXScB.gif",
    h32: "5ce7b616",
    h64: "93267f9820452ead",
    h32Signed: 1558689302,
    h64Signed: -7843441409665978707n,
  },
  {
    input: "heiå",
    h32: "db5abccc",
    h64: "b9d3d990d2001a1a",
    h32Signed: -614810420,
    h64Signed: -5056458740585194982n,
  },
  {
    input: "κόσμε",
    h32: "d855f606",
    h64: "a0488960c70d8772",
    h32Signed: -665455098,
    h64Signed: -6897111780568496270n,
  },
];

for (const testCase of testCases) {
  test(`h32 of ${testCase.input}`, async (t) => {
    const hasher = await xxhash();
    const h32 = hasher.h32(testCase.input).toString(16).padStart(8, "0");
    t.is(h32, testCase.h32);
  });

  test(`h32ToString of ${testCase.input}`, async (t) => {
    const hasher = await xxhash();
    const h32 = hasher.h32ToString(testCase.input);
    t.is(h32, testCase.h32);
  });

  test(`h32Raw of ${testCase.input}`, async (t) => {
    const encoder = new TextEncoder();
    const hasher = await xxhash();
    const h32 = hasher
      .h32Raw(encoder.encode(testCase.input))
      .toString(16)
      .padStart(8, "0");
    t.is(h32, testCase.h32);
  });

  test(`create32 of ${testCase.input}`, async (t) => {
    const hasher = await xxhash();
    const h32 = hasher
      .create32()
      .update(testCase.input)
      .digest()
      .toString(16)
      .padStart(8, "0");
    t.is(h32, testCase.h32);
  });

  test(`signed.h32 of ${testCase.input}`, async (t) => {
    const hasher = await xxhash();
    const hash = hasher.signed.h32(testCase.input);
    t.is(hash, testCase.h32Signed);
  });

  test(`signed.h32Raw of ${testCase.input}`, async (t) => {
    const encoder = new TextEncoder();
    const hasher = await xxhash();
    const hash = hasher.signed.h32Raw(encoder.encode(testCase.input));
    t.is(hash, testCase.h32Signed);
  });

  test(`signed.create32 of ${testCase.input}`, async (t) => {
    const hasher = await xxhash();
    const hash = hasher.signed.create32().update(testCase.input).digest();
    t.is(hash, testCase.h32Signed);
  });

  test(`h64 of ${testCase.input}`, async (t) => {
    const hasher = await xxhash();
    const h64 = hasher.h64(testCase.input);
    t.is(h64, BigInt(`0x${testCase.h64}`));
  });

  test(`h64ToString of ${testCase.input}`, async (t) => {
    const hasher = await xxhash();
    const h64 = hasher.h64ToString(testCase.input);
    t.is(h64, testCase.h64);
  });

  test(`h64Raw of ${testCase.input}`, async (t) => {
    const encoder = new TextEncoder();
    const hasher = await xxhash();
    const h64 = hasher.h64Raw(encoder.encode(testCase.input));
    t.is(h64, BigInt(`0x${testCase.h64}`));
  });

  test(`create64 of ${testCase.input}`, async (t) => {
    const hasher = await xxhash();
    const h64 = hasher
      .create64()
      .update(testCase.input)
      .digest()
      .toString(16)
      .padStart(16, "0");
    t.is(h64, testCase.h64);
  });

  test(`signed.h64 of ${testCase.input}`, async (t) => {
    const hasher = await xxhash();
    const hash = hasher.signed.h64(testCase.input);
    t.is(hash, testCase.h64Signed);
  });

  test(`signed.h64Raw of ${testCase.input}`, async (t) => {
    const encoder = new TextEncoder();
    const hasher = await xxhash();
    const h64 = hasher.signed.h64Raw(encoder.encode(testCase.input));
    t.is(h64, testCase.h64Signed);
  });

  test(`signed.create64 of ${testCase.input}`, async (t) => {
    const hasher = await xxhash();
    const h64 = hasher.signed.create64().update(testCase.input).digest();
    t.is(h64, testCase.h64Signed);
  });
}

test("h32 with different seeds produces different hashes", async (t) => {
  const hasher = await xxhash();
  const input = "different seeds";
  const h320 = hasher.h32(input, 0);
  const h32abcd = hasher.h32(input, 0xabcd);
  t.not(h320, h32abcd);
});

test("h64 with different seeds produces different hashes", async (t) => {
  const hasher = await xxhash();
  const input = "different seeds";
  const h640 = hasher.h64(input, 0n);
  const h64lowAbcd = hasher.h64(input, BigInt(0xabcd));
  const h64highAbcd = hasher.h64(input, BigInt(0xabcd) << (32n + BigInt(0)));
  t.not(h640, h64lowAbcd);
  t.not(h640, h64highAbcd);
  t.not(h64lowAbcd, h64highAbcd);
});

test("a string greater than the initial memory size works", async (t) => {
  const hasher = await xxhash();
  const bytesPerPage = 64 * 1024;
  const input = "z".repeat(bytesPerPage + 1);
  const h32 = hasher.h32ToString(input, 0);
  const h64 = hasher.h64ToString(input, 0n);
  t.is(h32, "7871ee9b");
  t.is(h64, "68278ba56dc14510");
});

test("streamed h32 with multiple inputs produces same hash", async (t) => {
  const hasher = await xxhash();
  const { update, digest } = hasher.create32(0);
  update("hello");
  update("world");
  t.is(digest(), hasher.h32("helloworld"));
});

test("streamed h64 with multiple inputs produces same hash", async (t) => {
  const hasher = await xxhash();
  const { update, digest } = hasher.create64(0n);
  update("hello");
  update("world");
  t.is(digest(), hasher.h64("helloworld"));
});

test("streamed h32 with buffer input produces same hash", async (t) => {
  const input = Buffer.from("helloworld");
  const hasher = await xxhash();
  t.is(hasher.create32(0).update(input).digest(), hasher.h32Raw(input));
});

test("streamed h64 with buffer input produces same hash", async (t) => {
  const input = Buffer.from("helloworld");
  const hasher = await xxhash();
  t.is(hasher.create64(0n).update(input).digest(), hasher.h64Raw(input));
});

test("h32 != signed.h32", async (t) => {
  const input = "abcd";
  const hasher = await xxhash();
  const hashUnsigned = hasher.h32(input);
  const hashSigned = hasher.signed.h32(input);
  t.not(hashUnsigned, hashSigned);
});

test("h64 != signed.h64", async (t) => {
  const input = "abcd";
  const hasher = await xxhash();
  const hashUnsigned = hasher.h64(input);
  const hashSigned = hasher.signed.h64(input);
  t.not(hashUnsigned, hashSigned);
});
